{"name":"doc","tagline":"Draft Documentation","body":"This is the wiki built-in to the project named \"doc\".\r\n\r\nThe content of this wiki is licensed under the same license that governs the project to which this wiki belongs. That license is available at https://github.com/wbhicks/doc/blob/master/LICENSE .\r\n\r\n**Disclaimer**: these are scratch notes for my own use. They'll almost certainly be useless if you don't have my machine, my offline projects, my offline whiteboard, etc.. Assume that everything here is out of date, incomplete, and wrong.\r\n\r\n* the book named _Pro Git_ on the MB: `file:///Users/Shared/Dev/Git/Pro_Git_book`\r\n* wiki markup syntax for editing this page (and any other GitHub wiki):\r\n    * https://help.github.com/articles/github-flavored-markdown\r\n    * http://daringfireball.net/projects/markdown/syntax\r\n    * https://github.com/github/linguist/blob/master/lib/linguist/languages.yml\r\n\r\n\r\nOn the MB, Git version 1.7.5.4 is already installed (this is machine-wide, not per-user -- i.e. the following applies no matter what OS X account you're logged into):\r\n\r\n```bash\r\n$ which git\r\n/usr/local/git/bin/git\r\n$ git --version\r\ngit version 1.7.5.4\r\n```\r\n\r\nOn the MB, suppose we have two OS X user accounts -- i and g. Choose which one you want to work in.\r\n\r\n1. Using OS X user account i\r\n\r\nWhenever you commit to a Git repository, the Git program will permanently label that commit with a username and email address of your choosing. They don't have to be real, and the Git program itself doesn't do anything to validate them.\r\n\r\nObviously, if you were contributing to a real-world project administered by other people, you would want your identity to be established and consistent. But here, we'll be making only sample commits to our own sample projects -- and, keeping in mind that our GitHub activity will be public, we also want to reduce our exposure to spam. So we'll choose a clearly made-up name/email pair.\r\n\r\nFirst, invoke Git and use it to associate a name and email with this OS account:\r\n\r\n```bash\r\n$ git config --global user.name \"Git username for MB acct i\"\r\n$ git config --global user.email fake_gu4mbai@git.sample.fake\r\n```\r\n\r\nThe argument `--global` means \"for this OS account\". (You'd think that \"global\" would mean \"for all accounts on this computer\", but there's a different argument for that, which we'll ignore: `--system`. You can also use per-repository settings.)\r\n\r\nNext, you can tell Git to list all (or just the `--global`) configuration values that you've given it so far:\r\n\r\n```bash\r\n$ git config --global --list\r\nuser.name=Git username for MB acct i\r\nuser.email=fake_gu4mbai@git.sample.fake\r\n```\r\n\r\nHow did Git remember? That's a useful question to ask when learning a new tool. Often the answer is that a running process has kept the values in memory, but in Git's case there is no daemon running in the background. Another common case is where the tool, upon installation, requires a connection to a separate database system (e.g. MySQL). Git, however, has none.\r\n\r\nThat leaves a simple configuration file as the most likely answer, and since our settings are per-user (thanks to `--global`), we know where to start looking:\r\n\r\n```bash\r\n$ ls -a ~ | grep git\r\n.gitconfig\r\n$ cat ~/.gitconfig \r\n[user]\r\n\tname = Git username for MB acct i\r\n\temail = fake_gu4mbai@git.sample.fake\r\n```\r\n\r\nNow let's switch our attention from Git to GitHub, because our commits won't be accepted by GitHub unless the email address shown above is known to a GitHub account. Fortunately, a GitHub account can know of more than one email address. \r\n\r\nUsing this GitHub account (wbhicks) as an example: I logged into GitHub.com in a browser and added the email address above at **Account Settings > Emails > Add another email address** . (At which point, the web page says that GitHub has \"... sent a verification email to fake_gu4mbai@git.sample.fake.\" However, the GitHub documentation [[acknowledges|https://help.github.com/articles/keeping-your-email-address-private]] that made-up email addresses are acceptable for such private purposes, so you can ignore the message. Keep in mind that such a conspicuously fake address is clearly not intended to deceive anyone.)\r\n\r\nNow back to Git. In Git, you work with _repositories_. For now, here are some **simplifying falsehoods**: you can think of a repository as equivalent to a project, and each repository/project will be embodied in its own local directory on your machine. Because we'll be juggling multiple repositories, we'll start by creating a parent directory to hold them. (This is analogous to the way that you manage multiple Eclipse projects within a single Eclipse workspace: the workspace is the parent directory, and each project is one of its subdirectories. As is the case with Eclipse, thinking in terms of a local Git workspace is a convenience, not a necessity.)\r\n\r\nUnlike the case with Eclipse, however, there is a remote partner in the picture: GitHub.com. We need to keep in mind that we'll be working with more than one GitHub account. So, let's first create a parent directory (workspace) to hold the repositories that will be associated specifically with this GitHub account (wbhicks):\r\n\r\n```bash\r\n$ mkdir ~/Git_wrkspc_wbhicks\r\n```\r\n\r\nThat's it, because Git doesn't acknowledge or make use of such a workspace. Git thinks only in terms of repositories, which -- as embodied by their corresponding local directories on your machine -- can be anywhere. Specifically, there is no Git equivalent to the Eclipse `.metadata` directory, which Eclipse generates inside your Eclipse workspace (and which is therefore independent of any one of your Eclipse projects).\r\n\r\nLet's return our attention for a moment to the `~/.gitconfig` file discussed earlier. Because that's just a file (and a very short and simple file at that), and because there's no Git sibling directory there (named, say, `~/.git_central_hq` or some such), you may be wondering where Git keeps all of the metadata that it needs to track and manage your local repositories. Where is its central database?\r\n\r\nIt turns out that Git, by design, has no such central database. Instead, each repository/project is completely self-contained. For example, if we had a Git repository at `~/some_project`, then there would be no Git metadata anywhere outside that directory that referred to it.\r\n\r\n**TODO: Does some_project/.git use absolute paths, or can some_project be moved via mv, Finder etc.?**\r\n\r\n> Sidenote:\r\n\r\n> One natural direction in which you could exploit this freedom would be to let Git repositories blossom all over your hard drive, in effect to gradually Git-ize your existing filesystem in an ad hoc, informal manner that would proceed opportunistically and piecemeal. In such an approach, you would give up on the idea of managing your repositories as a set (via \"workspaces\" or other such groupings), and instead use Git where and when its features suited you, as a general-purpose layer on top of the filesystem provided by OS X.\r\n\r\n> While there are important limitations and trade-offs in such an approach, it points to the idea of Git as a higher-level filesystem, and in fact Git was designed in part to support this. But we won't get into that here.\r\n\r\nThe workspace (`~/Git_wrkspc_wbhicks`) is empty, so let's populate it with some arbitrary repository, which we'll copy from somewhere else:\r\n\r\n```\r\n$ cd ~/Git_wrkspc_wbhicks\r\n$ git clone git://github.com/schacon/simplegit-progit.git\r\n```\r\n\r\nOur local Git program has now copied the repository named _simplegit-progit_ from somewhere else (as it happens, from GitHub) into the current directory (`~/Git_wrkspc_wbhicks`), where it shows up as the new directory `simplegit-progit`:\r\n\r\n```\r\n$ ls -a1\r\n.\r\n..\r\nsimplegit-progit\r\n```\r\n\r\n> Sidenote:\r\n\r\n> Here, I've passed the option `a` to `ls` to show that Git didn't add any \"hidden\" directory or file to the workspace when it created the `simplegit-progit` directory. Hidden directories/files are those starting with a dot, and the `a` option forces them to display. The `.` and `..` needn't concern us here, as they aren't related to Git. I passed the option `1` to `ls` to make the output more legible in this wiki.\r\n\r\nThanks to Git's clone command, we now have a complete, freestanding, fully independent copy of the entire simplegit-progit repository/project. Let's `cd` into it and list its top-level contents:\r\n\r\n```\r\n$ cd simplegit-progit\r\n$ ls -a1F\r\n./\r\n../\r\n.git/\r\nREADME\r\nRakefile\r\nlib/\r\n```\r\n\r\n(I added the `F` option to `ls` so that directories will be indicated with a trailing slash.) Notice that the project contains a hidden directory, `.git`. This is very significant, and now that we've noticed `.git`, it's time to drop some of the **simplifying falsehoods** that I stipulated earlier.\r\n\r\nEarlier, I deliberately conflated _repository_ with _project_. But it's more useful to think of the project as an abstract, but fully-defined, structure of files -- while the repository is entirely concrete, and is one of the places that the project is stored. In fact, the simplegit-progit project is actually stored **twice** in the `simplegit-progit` directory listed above! Here's how ...\r\n\r\n**TODO: Get someone who, unlike me, is _not_ a Git newbie to review this**\r\n\r\nThe simplegit-progit project itself consists of three siblings, two of which are files and one of which is a directory. The two files are `README` and `Rakefile`, and the directory is `lib`. The `.git` directory is _not_ part of the simplegit-progit project, strictly speaking.\r\n\r\nThe repository is the directory named `.git`. (Accordingly, the repository is also called the \"Git directory\".) But the repository holds much more than just the metadata needed to track changes to the project files: it also holds the project itself. The contents of the project (in simplegit-progit's case, that means README, Rakefile and lib) are stored in the repository.\r\n\r\nSo, on our local disk, there are two places where the contents of the simplegit-progit project are found: outside the repository (that is, outside the `.git` directory) and inside the repository (inside the `.git` directory). Both of these places are under the `simplegit-progit` directory.\r\n\r\nThe reason I referred to a project as an \"abstract\" structure is because a project doesn't always exist as \"real\" directories and files, meaning the kind that are managed by the OS and that are shown to us via tools like `ls` and Finder. For example, the instance of the project that exists alongside `.git` (in the form of `README`, `Rakefile` and `lib`) is clearly composed of real, OS-managed files. That's why they show up when we use `ls`. But the other instance of the project, the one that is located inside the repository (i.e. inside `.git`), does not have an OS-manipulable structure. \r\n\r\nThe proof is that, using Finder (or `ls` and `cd` in a shell), you cannot navigate inside `.git` to a place where README, Rakefile and lib are visible. The reason is that Git uses a sophisticated database structure to hold such content inside the repository.\r\n\r\nHow, then, did two instances of the same project come to be, inside the `simplegit-progit` directory? The answer is that, as soon as Git cloned the repository from the remote server (i.e. copied it from GitHub to your machine), it immediately performed a _checkout_ of the project from the local repository that it had just created. The result of the checkout was a _working copy_ of the project. Git had to do this in order to let you work with the files, e.g. read them, edit them, etc..\r\n\r\nThe source of the checkout operation was the local repository (`~/Git_wrkspc_wbhicks/simplegit-progit/.git`), where the project is not in human-usable form. (It's embedded in Git's internal database structure instead.) The destination of the checkout operation was the repository's parent directory (`~/Git_wrkspc_wbhicks/simplegit-progit`), where the project appears in human-usable form (the working copy).\r\n\r\nTo some extent, these semantics can be ignored: the working copy is the normal way to use a local repository, and `.git` is a hidden directory (so that the typical developer will be less likely to accidentally corrupt it). We can safely half-forget that `.git` exists, and imagine that Git accomplishes its tasks some other way. So, given a project named foo, it's reasonable for most purposes to think of a three-way equivalence among the project, the `foo` directory, and foo's local repository.\r\n\r\n---\r\n\r\n\r\nNow that we have a local Git repository, and a working copy of it has been automatically checked out for us, we can use Git's everyday features. We'll start by making changes to a single file, `README`, and tracking them with Git.\r\n\r\nWhat does Git have to say about `README` before we start? Because we haven't yet edited `README`, the Git commands **diff** and **status** show nothing special:\r\n\r\n```\r\n$ git diff README\r\n$ git status README \r\n# On branch master\r\nnothing to commit (working directory clean)\r\n```\r\n\r\nAs you can see, **diff** returned no output, and **status** returned a standard message indicating nothing about `README`.\r\n\r\nLet's try a third Git command, **log**, before we start editing `README` (I've truncated the output lines here):\r\n\r\n```\r\n$ git log README \r\ncommit a11be ...\r\nAuthor: Scott ...\r\nDate:   Sat Mar 15 ...\r\n    first commit\r\n```\r\n\r\nUnlike **diff** and **status**, **log** is showing us something specific about `README` even though we haven't edited our local copy. **log** shows us the complete history of a file, even from before the point at which we cloned the repository. (In this case, `README` doesn't have much of a history, only one entry.)\r\n\r\nNow, let's edit `README` (any editor will do) and save. For this example, we'll insert a sentence at the top. **diff** now shows that Git is aware of the change (I've truncated the output): \r\n\r\n```\r\n$ git diff README\r\ndiff --git a/README b/README\r\nindex a906cb2..d9efa26 100644\r\n--- a/README\r\n+++ b/README\r\n@@ -1,6 +1,7 @@\r\n+Tis but a flesh wound.\r\n...\r\n```\r\n\r\n**status** does too:\r\n\r\n```\r\n$ git status README \r\n# On branch master\r\n...\r\n#\tmodified:   README\r\n...\r\n```\r\n\r\nIf we were to use **log** at this point, it would show no change. Before **log** will reflect our change, we must _commit_ that change from the working copy to the local repository. A moment ago, when we saved our edit from within the editor, it affected only the working copy. That's because \r\n\r\n(1) a simple editor can't be expected to know about repositories or other revision-control artifacts, and\r\n\r\n(2) Git, as discussed earlier, has no daemon or other running process to \"keep an eye\" on the working copy.\r\n\r\nTo make a _commit_, we'll use Git's **commit** command, and supply it with a comment:\r\n\r\n```\r\n$ git commit -m \"This comment accompanies my first commit.\" README\r\n[master 92ee2c2] This comment accompanies my first commit.\r\n 1 files changed, 2 insertions(+), 1 deletions(-)\r\n```\r\n\r\nNow **log** reflects the change:\r\n\r\n```\r\n$ git log README \r\ncommit 92ee2 ...\r\nAuthor: Git username for MB acct i <fake_gu4mbai@git.sample.fake>\r\nDate:   Tue Oct 29 ...\r\n    This comment accompanies my first commit.\r\n\r\ncommit a11be ...\r\nAuthor: Scott ...\r\nDate:   Sat Mar 15 ...\r\n    first commit\r\n```\r\n\r\nJust before the commit, the output of **diff** and **status** reflected the fact that the working copy and the repository were \"out of sync\", as the changes we saved to the file in the working copy had not yet been applied to the repository. In effect, the working copy had gotten ahead of the repository. Now that we've committed those changes to the repository, the two are again in sync, as the output of **diff** will show:\r\n\r\n```\r\n$ git diff README\r\n$\r\n```\r\n\r\nJust as when we first used it, **diff** has returned no output, meaning that there is no difference. (The second \"$\" is just the next shell prompt.)\r\n\r\nFor the same reason, the output of **status** no longer mentions `README`:\r\n\r\n```\r\n$ git status README\r\n# On branch master\r\n# Your branch is ahead of 'origin/master' by 1 commit.\r\n#\r\nnothing to commit (working directory clean)\r\n```\r\n\r\nA new piece of information has appeared, which we'll ignore for now: \"Your branch is ahead of 'origin/master' by 1 commit.\" (It refers to the difference between our local repository and the remote repository from which we cloned it.)\r\n\r\nLet's edit `README` again, changing the first line, and see what that does to **diff**'s output (I've truncated the output):\r\n\r\n```\r\n$ git diff README\r\ndiff --git a/README b/README\r\nindex d9efa26..c819d3a 100644\r\n--- a/README\r\n+++ b/README\r\n@@ -1,4 +1,4 @@\r\n-Tis but a flesh wound.\r\n+It's just a flesh wound.\r\n...\r\n```\r\n\r\nHere's what to focus on. Earlier, it showed this:\r\n\r\n```\r\n+Tis but a flesh wound.\r\n```\r\n\r\nBut now it shows this:\r\n\r\n```\r\n-Tis but a flesh wound.\r\n+It's just a flesh wound.\r\n```\r\n\r\nThe minus sign shows what we removed, and the plus sign shows what we added.\r\n\r\nNow let's commit that change to the repository, again supplying a comment, and see how that affects the log:\r\n\r\n```\r\n$ git commit -m \"This 2nd comment accompanies my 2nd commit.\" README\r\n[master 4550ce4] This 2nd comment accompanies my 2nd commit.\r\n 1 files changed, 1 insertions(+), 1 deletions(-)\r\n$ git log README \r\ncommit 4550c ...\r\nAuthor: Git username for MB acct i <fake_gu4mbai@git.sample.fake>\r\nDate:   Wed Oct 30 ...\r\n    This 2nd comment accompanies my 2nd commit.\r\n\r\ncommit 92ee2 ...\r\nAuthor: Git username for MB acct i <fake_gu4mbai@git.sample.fake>\r\nDate:   Tue Oct 29 ...\r\n    This comment accompanies my first commit.\r\n\r\ncommit a11be ...\r\nAuthor: Scott ...\r\nDate:   Sat Mar 15 ...\r\n    first commit\r\n```\r\n\r\n(From now on, this tutorial will omit invocations of **diff**, **status** and **log** unless there's a particular point to make. If you use them frequently, it'll keep the context of your current work fresh in your mind. At a shell prompt, up-arrow is a great tool for doing this easily!)\r\n\r\nNext, we'll create a couple of new files in the working copy:\r\n\r\n```\r\n$ ls -1\r\nREADME\r\nRakefile\r\nlib\r\n$ touch food.txt\r\n$ touch clothes.txt\r\n$ ls -1\r\nREADME\r\nRakefile\r\nclothes.txt\r\nfood.txt\r\nlib\r\n```\r\n\r\nWe'll edit them (not shown here, unsurprisingly) and admire our handiwork:\r\n\r\n```\r\n$ cat food.txt \r\ngrapes\r\ndormouse\r\nsherbet\r\n$ cat clothes.txt \r\nsandals\r\ntoga\r\nlaurels\r\n```\r\n\r\nNext, a bit of housekeeping. As these are new files, we must make Git aware of them, by using Git's **add** command. To show that they were added, we'll use **status**. No filename is necessary with **status**:\r\n\r\n```\r\n$ git add *.txt\r\n$ git status\r\n# On branch master\r\n# Your branch is ahead of 'origin/master' by 2 commits.\r\n#\r\n# Changes to be committed:\r\n#   (use \"git reset HEAD <file>...\" to unstage)\r\n#\r\n#\tnew file:   clothes.txt\r\n#\tnew file:   food.txt\r\n```\r\n\r\nNow we can use a single **commit** command to commit both of these new files from the working copy to the repository (the \"-a\" flag isn't necessary, but is included here for consistency):\r\n\r\n```\r\n$ git commit -a -m \"Romani ite domum\"\r\n[master 16c0aa0] Romani ite domum\r\n 2 files changed, 6 insertions(+), 0 deletions(-)\r\n create mode 100644 clothes.txt\r\n create mode 100644 food.txt\r\n```\r\n\r\nAs with **status**, we didn't need to specify the filenames with **commit**. This commit operation covered every changed file in the working copy, as long as that file was either (a) present in the repository when it was cloned, or (b) brought to Git's attention via **add**. Let's edit both files again, show them here with cat and re-commit:\r\n\r\n```\r\n$ cat food.txt \r\ngrapes\r\ndormouse\r\nWe're out of sherbet. How about some dung?\r\n$ cat clothes.txt \r\nfelt boots\r\ntoga\r\nlaurels\r\n$ git commit -a -m \"Rome is falling\"\r\n[master 8aa8c0c] Rome is falling\r\n 2 files changed, 2 insertions(+), 2 deletions(-)\r\n```\r\n\r\nAnd again:\r\n\r\n```\r\n$ cat food.txt \r\nprunes\r\ndormouse jerky\r\nDung it is.\r\n$ cat clothes.txt \r\nfelt boots\r\ntoga\r\nhorned helment\r\n$ git commit -a -m \"Rome has fallen. (Scarsdale's next.)\"\r\n[master ef755fd] Rome has fallen. (Scarsdale's next.)\r\n 2 files changed, 4 insertions(+), 4 deletions(-)\r\n```\r\n\r\nAnd again:\r\n\r\n```\r\n$ cat food.txt \r\nrabbit stew\r\nhamster stuffed with elderberries\r\nDung it is.\r\n$ cat clothes.txt \r\nfelt boots\r\nchain mail\r\nhorned helment\r\n$ git commit -a -m \"England AD 787\"\r\n[master 3a6f7ca] England AD 787\r\n 2 files changed, 3 insertions(+), 3 deletions(-)\r\n```\r\n\r\nJust as we were able to omit the filename from **status** and **commit**, we can do so with **diff** and **log** (most lines left out here):\r\n\r\n```\r\n$ git diff\r\n$ git log\r\n...\r\n    England AD 787\r\n...\r\n    Rome has fallen. (Scarsdale's next.)\r\n...\r\n    Rome is falling\r\n...\r\n    Romani ite domum\r\n...\r\n    This 2nd comment accompanies my 2nd commit.\r\n...\r\n    This comment accompanies my first commit.\r\n...\r\n    changed the verison number\r\n...\r\n    removed unnecessary test code\r\n...\r\n    first commit\r\n```\r\n\r\nTODO: better diff tool (or shorter commit IDs?) - whole point of above seq\r\nTODO: log is repo-centric, vs. diff/status straddles working-copy & repo\r\n\r\n\r\nNow let's get an overview of the changes we've committed. To do so, we'll use a GUI tool that's already installed:\r\n\r\n```\r\n$ gitk\r\n```\r\n\r\nThe resulting OS X window doesn't come to the foreground, so use cmd-tab or the dock to select it. The lower half of the window is divided up the middle by a resize bar; drag it about two-thirds to the right (or else the \"Line diff\" selection list may be hidden). Near the left edge of the window, confirm that the \"Diff\" radio button is selected; over on the righthand half of the window, confirm that the \"Patch\" radio button is selected. In the upper-lefthand pane, use your up- and down-arrow keys to select each of the commits in turn, and as you do so, watch the changes in the lower-lefthand pane (divided into a \"clothes.txt\" section and a \"food.txt\" section). Repeat the experiment for each of the three values available in the selection list (the one that's on the same row as the \"Diff\" radio button): Line diff, Markup words, Color words.\r\n\r\nThat's it for our tour of standalone Git. Next, we'll see what GitHub adds to the process.\r\n\r\nTODO: haven't covered creating a repo from scratch locally\r\n\r\nEarlier, we cloned someone else's repository. Now, let's create a repository from scratch. We could do this on our local filesystem, whether inside our informal workspace (`~/Git_wrkspc_wbhicks`) or not. But we'll do it on the GitHub side instead.\r\n\r\nUsing this GitHub account (wbhicks) as an example: I logged into GitHub.com in a browser and selected the **Repositories** tab, then the **New** button. Under \"Repository name\", I entered `annotated-configs`, checked \"Initialize this repository with a README\", and from the \"Add a license\" dropdown list, selected \"GPL v3\". Then I clicked **Create repository**. This took me to the page `https://github.com/wbhicks/annotated-configs`.\r\n\r\nSo far, our new repository exists only on GitHub. Let's add a file to it, entirely within the browser. My example: In the middle of the page, I clicked the icon that looks like a document with a plus sign in it. I gave it the name \"made-in-browser.txt\" and added some lines in the body. I then clicked **Commit New File** (which implicitly accepts the default value under \"Commit summary\"). I made a few more revisions to the file, still entirely within the browser.\r\n\r\nLet's use GitHub's tools to examine the file history. First, GitHub's \"blame view\": start on the repository's home page, e.g. `https://github.com/wbhicks/annotated-configs`, click on the filename, and display the \"blame view\" by clicking the **Blame** button on the horizontal button bar. Afterward, click **Normal View** to return.\r\n\r\nSecond, GitHub's \"history view\": click the **History** button on the horizontal button bar. The revisions to the file are displayed in a stack. In the top item of the stack (i.e. the most recent revision), click the right-side button with the random label[1]. (That label consists of 10 hexadecimal digits, and it's the unique ID of that revision). The button I'm describing is directly _above_ the link labelled \"Browse code\". (If you click on \"Browse code\" instead, you'll get a less colorful view.) Afterward, hit your browser's back button a couple of times to return to the \"normal view\" (the horizontal button bar isn't shown in \"history view\" -- an oversight I think).\r\n\r\n> [1]equivalently, you can click on the comment for that revision\r\n\r\nNow that we've learned how to create a new file directly in a repository on GitHub, you might be wondering how to upload a file from your local filesystem to the repository on GitHub, without first being required to clone that repository onto your local filesystem. The answer is that there's no way to do so[2], because cloning the repository to your machine is considered to be the natural way to work with it.\r\n\r\n> [2]see https://help.github.com/articles/issue-attachments for the exception that proves the rule\r\n\r\nTherefore, let's take the repository we've created on GitHub, and clone it onto our local machine, so that we can add a local file to it. My example: \r\n\r\nEarlier, when we cloned a remote repo (the simplegit-progit project), we used the Git protocol:\r\n\r\n```\r\n$ git clone git://github.com/schacon/simplegit-progit.git\r\n```\r\n\r\nBut going forward, we'll use the SSH protocol[3], and that means that the argument we pass to Git's clone command will have a fundamentally different form:\r\n\r\n> [3]TODO: explain\r\n\r\n```\r\n$ git clone git@github.com:schacon/simplegit-progit.git\r\n```\r\n\r\nThe name of the project will be different too, since the repo we want to clone is the annotated-configs project that we just created on the GitHub side:\r\n\r\n```\r\n$ git clone git@github.com:wbhicks/annotated-configs.git\r\n```\r\n\r\n> Sidenote: \r\n\r\n> How do you know what argument to pass to Git's clone command in your local shell? GitHub will tell you. On the repository's homepage, there's a box in the righthand margin that generates the right argument for you. Below the box, click the \"SSH\" link in the line that starts \"You can clone with ...\", since SSH is the protocol we want to use. That will populate the box correctly. As confirmation, observe that the label \"SSH clone URL\" now appears above the box.\r\n\r\nBut when we actually try to clone, we get an error:\r\n\r\n```\r\n$ git clone git@github.com:wbhicks/annotated-configs.git\r\nCloning into annotated-configs...\r\nThe authenticity of host 'github.com (192.30.252.131)' can't be established.\r\nRSA key fingerprint is ...\r\nAre you sure you want to continue connecting (yes/no)? yes\r\nWarning: Permanently added 'github.com,192.30.252.131' (RSA) to the list of known hosts.\r\nPermission denied (publickey).\r\nfatal: The remote end hung up unexpectedly\r\n```\r\n\r\nAnd if you re-try, you get the same error, minus the warning:\r\n\r\n```\r\n$ git clone git@github.com:wbhicks/annotated-configs.git\r\nCloning into annotated-configs...\r\nWarning: Permanently added the RSA host key for IP address '192.30.252.130' to the list of known hosts.\r\nPermission denied (publickey).\r\nfatal: The remote end hung up unexpectedly\r\n```\r\n\r\nSo, we must take care of a preliminary step if we want to make any progress using the SSH protocol. That step is to create, and correctly place, the two parts of what's called a public/private keypair.\r\n\r\nTODO: Explain all about PKI. A couple of sentences should do it.\r\n\r\n1. Using OS X user account i\r\n\r\nUnder OS X user account i, we'll have to establish our PKI credentials with GitHub from scratch. Let's follow (more or less) the instructions at https://help.github.com/articles/generating-ssh-keys .\r\n\r\nFirst, let's see if user i already has a public/private keypair:\r\n\r\n```\r\n$ ls -la1 ~/.ssh\r\n.\r\n..\r\nknown_hosts\r\n```\r\n\r\nSo, it doesn't, or else we would have seen a pair of files, id_rsa and id_rsa.pub. Let's generate that keypair (just hit enter whenever the process asks for input):\r\n\r\n```\r\n$ ssh-keygen -t rsa -C \"This comment could have said anything.\"\r\nGenerating public/private rsa key pair.\r\nEnter file in which to save the key (/Users/i/.ssh/id_rsa): \r\nEnter passphrase (empty for no passphrase): \r\nEnter same passphrase again: \r\nYour identification has been saved in /Users/i/.ssh/id_rsa.\r\nYour public key has been saved in /Users/i/.ssh/id_rsa.pub.\r\n...\r\n```\r\n\r\nNow let's confirm that the keypair has been generated and placed in ~/.ssh:\r\n\r\n```\r\n$ ls -la1 ~/.ssh\r\n.\r\n..\r\nid_rsa\r\nid_rsa.pub\r\nknown_hosts\r\n```\r\n\r\nNow we need to provide GitHub with the public half of that keypair -- i.e., id_rsa.pub -- by associating it with a GitHub account. Once we do, we'll be able to enjoy two-way communication between (1) the `git` program on our local machine and (2) GitHub. Specifically, all the repos in that particular GitHub account will be manipulable by our local Git.[4]\r\n\r\n> [4]Admittedly, when we started this tutorial, we were able to clone a repo from GitHub right away. However, we wouldn't have been able to propagate our edits back to the point of origin. (Bonus points for understanding why I didn't say \"back to the source\" just there.) Using a public/private keypair isn't the only way to allow such two-way communication, but that's how the SSH protocol works; and until the keypair is set up properly, even the harmless (\"read-only\", or \"non-destructive\") step of cloning _from_ a remote repo will fail, if SSH is the protocol.\r\n\r\nMy example: In the browser, log into the wbhicks account on GitHub and click the **Account Settings** icon in the upper-righthand corner of the page. Click on the \"SSH Keys\" link, then the **Add SSH key** button.\r\n\r\nSwitch over to a shell prompt (in your Terminal.app window) and execute either of these commands (bonus point: why are they equivalent?):\r\n\r\n```\r\n$ pbcopy < ~/.ssh/id_rsa.pub\r\n```\r\n\r\nor\r\n\r\n```\r\n$ cat ~/.ssh/id_rsa.pub | pbcopy\r\n```\r\n\r\nThat will copy your public key to your clipboard. Now switch back to your browser window, click into the text entry area labelled \"Key\", and hit cmd-c to paste the public key into GitHub's form. (Don't type anything else, such as a return, into that text entry area.) Add a title if you like, and click **Add key** to upload the form to GitHub. (You'll need your GitHub password.) Now you should see that the public key has been added to the list of public keys for that GitHub account.\r\n\r\nTODO: explain list; why multiple entries in the 1st place\r\n\r\n---\r\n\r\nTODO: explain following mention of known_hosts (maybe due to GitHub load balancing?):\r\n\r\n```\r\n$ git push\r\nWarning: Permanently added the RSA host key for IP address '192.30.252.129' to the list of known hosts.\r\nCounting objects: 5, done.\r\nDelta compression using up to 2 threads.\r\nCompressing objects: 100% (2/2), done.\r\nWriting objects: 100% (3/3), 340 bytes, done.\r\nTotal 3 (delta 1), reused 0 (delta 0)\r\nTo git@github.com:wbhicks/annotated-configs.git\r\n   f08bae0..460b97f  master -> master\r\n```\r\n\r\nhappened again:\r\n\r\n```\r\n$ git push\r\nWarning: Permanently added the RSA host key for IP address '192.30.252.128' to the list of known hosts.\r\n...\r\n```\r\n\r\nTODO: refactor throughout, above, with this dry-run timesaver:\r\n\r\n```\r\n$ git add -n .\r\n...\r\n$ git add .\r\n```\r\n\r\nTODO: .DS_Store files aren't added, even recursively. Nice, but does that apply to all dot files?","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}